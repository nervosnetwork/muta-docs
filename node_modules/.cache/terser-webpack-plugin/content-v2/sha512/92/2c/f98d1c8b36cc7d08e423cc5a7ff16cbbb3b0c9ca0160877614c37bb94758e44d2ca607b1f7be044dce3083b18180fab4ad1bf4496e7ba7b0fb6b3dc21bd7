{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{298:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"frontMatter\",(function(){return r})),n.d(t,\"metadata\",(function(){return c})),n.d(t,\"rightToc\",(function(){return l})),n.d(t,\"default\",(function(){return m}));var o=n(1),a=n(6),i=(n(0),n(307)),s=n(353),r={last_modified_on:\"2020-07-13\",$schema:\"/.meta/.schemas/guides.json\",title:\"Building & Managing Complex Configs\",description:\"Strategies for building and managing complex Vector configs\",author_github:\"https://github.com/zhouyun-zoe\",tags:[\"type: guide\",\"domain: config\"]},c={categories:[{name:\"advanced\",title:\"Advanced\",description:\"Go the basics, become a Vector pro, and extract the full potential of Vector.\",permalink:\"/guides/advanced\"}],coverLabel:\"Building & Managing Complex Configs\",description:\"Strategies for building and managing complex Vector configs\",permalink:\"/guides/advanced/managing-complex-configs\",readingTime:\"5 min read\",source:\"@site/guides/advanced/managing-complex-configs.md\",tags:[{label:\"type: guide\",permalink:\"/guides/tags/type-guide\"},{label:\"domain: config\",permalink:\"/guides/tags/domain-config\"}],title:\"Building & Managing Complex Configs\",truncated:!1,prevItem:{title:\"Next Steps\",permalink:\"/guides/getting-started/next-steps\"},nextItem:{title:\"Custom Aggregations with Lua\",permalink:\"/guides/advanced/custom-aggregations-with-lua\"}},l=[{value:\"Generating Configs\",id:\"generating-configs\",children:[]},{value:\"Testing Configs\",id:\"testing-configs\",children:[]},{value:\"Organizing Configs\",id:\"organizing-configs\",children:[]},{value:\"Updating Configs\",id:\"updating-configs\",children:[]}],u={rightToc:l};function m(e){var t=e.components,n=Object(a.a)(e,[\"components\"]);return Object(i.b)(\"wrapper\",Object(o.a)({},u,n,{components:t,mdxType:\"MDXLayout\"}),Object(i.b)(s.a,{name:\"guide\",mdxType:\"Assumptions\"},Object(i.b)(\"ul\",null,Object(i.b)(\"li\",{parentName:\"ul\"},\"You understand the \",Object(i.b)(\"a\",Object(o.a)({parentName:\"li\"},{href:\"/docs/about/concepts/\"}),\"basic Vector concepts\"),\" and understand \",Object(i.b)(\"a\",Object(o.a)({parentName:\"li\"},{href:\"/guides/getting-started/your-first-pipeline/\"}),\"how to set up a pipeline\"),\".\"))),Object(i.b)(\"p\",null,\"Writing large configuration files is not yet an official olympic event. However,\\nit's still a good idea to get yourself ahead of the competition. In this guide\\nwe're going to cover some tips and tricks that will help you write clear, bug\\nfree Vector configs that are easy to maintain.\"),Object(i.b)(\"h2\",{id:\"generating-configs\"},\"Generating Configs\"),Object(i.b)(\"p\",null,\"In Vector each component of a pipeline specifies which components it consumes\\nevents from. This makes it very easy to build multiplexed topologies. However,\\nwriting a chain of transforms this way can sometimes be frustrating as the\\nnumber of transforms increases.\"),Object(i.b)(\"p\",null,\"Luckily, the Vector team are desperate for your approval and have worked hard to\\nmitigate this with the \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"generate\"),\" subcommand, which can be used to generate the\\nboilerplate for you. The command expects a list of components, where it then\\ncreates a config with all of those components connected in a linear chain.\"),Object(i.b)(\"p\",null,\"For example, if we wished to create a chain of three transforms; \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"json_parser\"),\",\\n\",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"add_fields\"),\", and \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"remove_fields\"),\", we can run:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-bash\"}),\"vector generate /json_parser,add_fields,remove_fields > vector.toml\\n# Find out more with `vector generate --help`\\n\")),Object(i.b)(\"p\",null,\"And most of the boilerplate will be written for us, with each component printed\\nwith an \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"inputs\"),\" field that specifies the component before it:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-toml\",metastring:'title=\"vector.toml\"',title:'\"vector.toml\"'}),'[transforms.transform0]\\n  inputs = [ \"somewhere\" ]\\n  type = \"json_parser\"\\n  #\\xa0etc ...\\n\\n[transforms.transform1]\\n  inputs = [ \"transform0\" ]\\n  type = \"add_fields\"\\n  #\\xa0etc ...\\n\\n[transforms.transform2]\\n  inputs = [ \"transform1\" ]\\n  type = \"remove_fields\"\\n  #\\xa0etc ...\\n')),Object(i.b)(\"p\",null,\"The names of the generated components are sequential (\",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"transform0\"),\",\\n\",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"transform1\"),\", and so on). It's therefore worth doing a search and replace with\\nyour editor to give them better names, e.g. \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"s/transform2/scrub_emails/g\"),\".\"),Object(i.b)(\"h2\",{id:\"testing-configs\"},\"Testing Configs\"),Object(i.b)(\"p\",null,\"Test driven Configurationn is a paradigm we just made up, so there's still time\\nfor you to adopt it \",Object(i.b)(\"em\",{parentName:\"p\"},\"before\"),\" it's cool. Vector supports complementing your\\nconfigs with \",Object(i.b)(\"a\",Object(o.a)({parentName:\"p\"},{href:\"/guides/advanced/unit-testing/\"}),\"unit tests\"),\", and as it turns out\\nthey're also pretty useful during the building stage.\"),Object(i.b)(\"p\",null,\"Let's imagine we are in the process of building the config from the \",Object(i.b)(\"a\",Object(o.a)({parentName:\"p\"},{href:\"/guides/advanced/unit-testing/\"}),\"unit test\\nguide\"),\", we might start off with our source and\\nthe grok parser:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-toml\",metastring:'title=\"vector.toml\"',title:'\"vector.toml\"'}),'[sources.over_tcp]\\n  type = \"socket\"\\n  mode = \"tcp\"\\n  address = \"0.0.0.0:9000\"\\n\\n[transforms.foo]\\n  type = \"grok_parser\"\\n  inputs = [\"over_tcp\"]\\n  pattern = \"%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}\"\\n')),Object(i.b)(\"p\",null,\"A common way to test this transform might be to temporarily change the source\\ninto a \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"stdin\"),\" type, add a \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"console\"),\" sink pointed to our target transform, and\\nrun it with some sample data. However, this is awkward as it means distorting\\nour config to run tests rather than focusing on features.\"),Object(i.b)(\"p\",null,\"Instead, we can leave our source as a \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"socket\"),\" type and add a unit test to the\\nend of our config:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-toml\",metastring:'title=\"vector.toml\"',title:'\"vector.toml\"'}),'[[tests]]\\n  name = \"check_simple_log\"\\n\\n  [[tests.inputs]]\\n    insert_at = \"foo\"\\n    type = \"raw\"\\n    value = \"2019-11-28T12:00:00+00:00 info Sorry, I\\'m busy this week Cecil\"\\n\\n  [[tests.outputs]]\\n    extract_from = \"foo\"\\n')),Object(i.b)(\"p\",null,\"When we add a unit test output without any conditions it will simply print the\\ninput and output events of a transform, allowing us to inspect its behavior:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-sh\"}),'$ vector test ./vector.toml\\nRunning vector.toml tests\\ntest vector.toml: check_simple_log ... passed\\n\\ninspections:\\n\\n--- vector.toml ---\\n\\ntest \\'check_simple_log\\':\\n\\ncheck transform \\'foo\\' payloads (events encoded as JSON):\\n  input: {\"timestamp\":\"2020-02-11T15:04:02.361999Z\", \"message\":\"2019-11-28T12:00:00+00:00 info Sorry, I\\'m busy this week Cecil\"}\\n  output: {\"level\":\"info\",\"message\":\"Sorry, I\\'m busy this week Cecil\", \"timestamp\":\"2019-11-28T12:00:00+00:00\"}\\n')),Object(i.b)(\"p\",null,\"As we introduce new transforms to our config we can change the test output\\nto check the latest transform. Or, occasionally, we can add conditions to an\\noutput in order to turn it into a regression test:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-toml\",metastring:'title=\"vector.toml\"',title:'\"vector.toml\"'}),'[[tests]]\\n  name = \"check_simple_log\"\\n\\n  [[tests.inputs]]\\n    insert_at = \"foo\"\\n    type = \"raw\"\\n    value = \"2019-11-28T12:00:00+00:00 info Sorry, I\\'m busy this week Cecil\"\\n\\n  #\\xa0This is now a regression test\\n  [[tests.outputs]]\\n    extract_from = \"foo\"\\n    [[tests.outputs.conditions]]\\n      type = \"check_fields\"\\n      \"message.equals\" = \"Sorry, I\\'m busy this week Cecil\"\\n\\n  # And we add a new output without conditions for inspecting\\n  # a new transform\\n  [[tests.outputs]]\\n    extract_from = \"bar\"\\n')),Object(i.b)(\"p\",null,\"How many tests you add is at your discretion, but you probably don't need to\\ntest every single transform. We recommend every four transforms, except during a\\nfull moon when you should test every two just to be sure.\"),Object(i.b)(\"h2\",{id:\"organizing-configs\"},\"Organizing Configs\"),Object(i.b)(\"p\",null,\"Building configs is only the beginning. Once it's built you need to make sure\\npesky meddlers don't ruin it. The best way to keep on top of that is to break\\nlarge configs down into smaller more manageable pieces.\"),Object(i.b)(\"p\",null,\"With Vector you can split a config down into as many files as you like and run\\nthem all as a larger topology:\"),Object(i.b)(\"pre\",null,Object(i.b)(\"code\",Object(o.a)({parentName:\"pre\"},{className:\"language-bash\"}),\"#\\xa0These three examples run the same two configs together:\\n$ vector -c ./configs/foo.toml -c ./configs/bar.toml\\n$ vector -c ./configs/*.toml\\n$ vector -c ./configs/foo.toml ./configs/bar.toml\\n\")),Object(i.b)(\"p\",null,\"If you have a large chain of components it's a good idea to break them out into\\nindividual files, each with its own unit tests.\"),Object(i.b)(\"h2\",{id:\"updating-configs\"},\"Updating Configs\"),Object(i.b)(\"p\",null,\"Sometimes it's useful to update Vector configs on the fly. If you find yourself\\ntinkering with a config that Vector is already running you can prompt it to\\nreload the changes you've made by sending it a \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"SIGHUP\"),\" signal.\"),Object(i.b)(\"p\",null,\"If you're running Vector in environments where it's not possible to issue\\n\",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"SIGHUP\"),\" signals you can instead run it with the \",Object(i.b)(\"inlineCode\",{parentName:\"p\"},\"--watch-config\"),\" flag and it'll\\nautomatically gobble up changes whenever the file is written to.\"))}m.isMDXComponent=!0},314:function(e,t,n){\"use strict\";var o=n(0),a=n.n(o),i=n(306),s=n.n(i);n(93);t.a=function({children:e,className:t,fill:n,icon:o,rounded:i,type:r}){let c=null;switch(r){case\"danger\":c=\"alert-triangle\";break;case\"success\":c=\"check-circle\";break;case\"warning\":c=\"alert-triangle\";break;default:c=\"info\"}return a.a.createElement(\"div\",{className:s()(t,\"alert\",\"alert--\"+r,{\"alert--fill\":n,\"alert--icon\":!1!==o,\"alert--rounded\":!0===i}),role:\"alert\"},!1!==o&&a.a.createElement(\"i\",{className:s()(\"feather\",\"icon-\"+(o||c))}),e)}},353:function(e,t,n){\"use strict\";var o=n(0),a=n.n(o),i=n(314);t.a=function({children:e,name:t}){return a.a.createElement(i.a,{type:\"info\",fill:!0,icon:!1,rounded:!0,className:\"list--icons list--icons--arrow list--tight list--indent margin-bottom--lg\"},a.a.createElement(\"p\",{class:\"text--lg margin-bottom--sm\",style:{marginTop:\"-0.25em\"}},\"Before you begin, this \",t||\"page\",\" assumes the following:\"),e)}}}]);","extractedComments":[]}